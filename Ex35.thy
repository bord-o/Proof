theory Ex35 imports Main

begin
(*
Exercise 3.5. A context-free grammar can be seen as an inductive definition
where each nonterminal A is an inductively defined predicate on lists of ter-
minal symbols: A(w) means that w is in the language generated by A. For
example, the production S \<rightarrow>aSb can be viewed as the implication S w= \<Rightarrow>
S (a # w @ [b]) where a and b are terminal symbols, i.e., elements of some
alphabet. The alphabet can be defined like this: datatype alpha= a | b |. . .
Define the two grammars (where \<epsilon> is the empty word)
S \<rightarrow> \<epsilon> | aSb | SS
T \<rightarrow> \<epsilon> | T aT b
as two inductive predicates. If you think of a and b as “(” and “)”, the
grammars define balanced strings of parentheses. Prove T w= \<Rightarrow>S w and
S w= \<Rightarrow>T w separately and conclude S w= T w.
*)

datatype alphabet = 
  a
  | b

inductive S :: "alphabet list \<Rightarrow> bool" where
  empty: "S []" |
  balance: "S xs \<Longrightarrow> S (a # xs @ [b])" |
  mult: "S xs \<Longrightarrow> S ys \<Longrightarrow> S (xs @ ys)"

inductive T :: "alphabet list \<Rightarrow> bool" where
  empty': "T []" |
  balance': "T xs \<Longrightarrow> T ys \<Longrightarrow>  T (xs @ (a # ys @ [b]))" 

theorem ts_eq: "T w \<Longrightarrow> S w"
  apply(induction rule:T.induct)
   apply(rule S.empty)
  apply(simp add:balance mult)
  done

lemma T_append_aux: "T ys \<Longrightarrow> T xs \<Longrightarrow> T (xs @ ys)"
  apply(induction ys  rule: T.induct)
   apply(simp)
  by (metis append.assoc balance')

theorem st_eq: "S w \<Longrightarrow> T w"
  apply(induction rule: S.induct)
    apply(rule T.empty')
   apply(simp_all add:T_append_aux)
  using balance' empty' by force

 
(*
fun balancer :: " nat \<Rightarrow> alphabet list \<Rightarrow> bool" where
  "balancer 0  [] = True" |
  "balancer op [] = False" | 
  "balancer op (a#xs) = balancer (Suc op) xs" |
  "balancer 0 (b#xs) = False" |
  "balancer (Suc op) (b#xs) = balancer op xs"

value "balancer 0 ([] :: alphabet list)"

fun balanced :: "alphabet list \<Rightarrow> bool" where "balanced xs = balancer 0 xs"
*)

end